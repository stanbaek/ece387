# 🔬 Lab6: IMU


## 📌 Objectives

- Students should be able to u

## 📜 Overview  

In real-world applications, an Inertial Measurement Unit (IMU) provides essential motion data, including orientation, angular velocity, and linear acceleration. The [ICM-20648 6-Axis MEMS MotionTracking Device](https://invensense.tdk.com/products/motion-tracking/6-axis/icm-20648/) from TDK integrates a 3-axis gyroscope, a 3-axis accelerometer, and a Digital Motion Processor (DMP). This IMU is embedded in the OpenCR1.0 board, an open-source robot controller featuring an ARM Cortex-M7 processor. The OpenCR board uses an Extended Kalman Filter (EKF) to fuse sensor data, generating IMU estimates at a rate of 170 updates per second.

```{image} ./figures/IMU.jpg
:width: 380
:align: center
```
<br>

The IMU plays a crucial role in determining the robot's state and enhancing navigation accuracy. When combined with tachometer data, it helps estimate the robot's position over time (odometry). 

```{image} ./figures/TurtleBot3_Coordinates.png
:width: 280
:align: center
```

### IMU Calibration

As mentioned earlier, multiple sensors work together to estimate the TurtleBot3's attitude and heading. These sensors are highly sensitive to magnetic fields, which vary by location and device. Even common electronic components generate small magnetic fields, including those from the OpenCR board itself. While the IMU is strategically placed at the center of the robot for optimal performance, it is still exposed to various magnetic interferences.

Fortunately, the TurtleBot3 developers accounted for this challenge. Each time you run the serial node to connect to the robot, the IMU automatically calibrates itself, ensuring more reliable readings.

## 🌱 Pre-Lab: Testing the IMU  

### Step 1: Launch the TurtleBot3 Simulation

1. Open a terminal and start the TurtleBot3 simulation in Gazebo:
   ```bash
   $ ros2 launch turtlebot3_gazebo turtlebot_world.launch
   ```

### Step 2: Verify Communication with the Master

1. Ensure the TurtleBot3 is properly communicating with the Master by listing active topics:
   ```bash
   $ ros2 topic list
   ```
2. You should see the following topics, including `/imu` and `/odom`:
   ```bash
   /battery_state
   /cmd_vel
   /imu
   /joint_states
   /magnetic_field
   /odom   
   /tf_static
    ```

### Step 3: Examine the `/imu` and `/odom` Topics

1. Run the `gamepad` and `joy` nodes.
2. As you move the robot in Gazebo, observe the `/imu` and `/odom` topics:
   ```bash
   $ ros2 topic echo /imu
   ```
   ```bash
   $ ros2 topic echo /odom
   ```
3. Pay close attention to the `pose` field. In future labs, be careful not to confuse the different pose hierarchies within the `Imu` and `Odom` messages.

### Step 4: Visualizing Data in `rqt`

1. Open `rqt`:
   ```bash
   $ rqt
   ```
2. Move the robot in Gazebo and observe the `/imu` and `/odom` topics in `rqt`.
3. In Gazebo, navigate to `Models` > `burger`, then in the `property` section, select `pose` to display the robot's position and orientation (expressed in roll-pitch-yaw format).
4. In `rqt`, activate the `Topic Monitor` and enable `/imu` and `/odom` to track orientation and position in real time.
5. Note that orientation in `rqt` is shown using quaternions.
6. The pose values in Gazebo and rqt are not the same. Gazebo simulation publishes position and orientation with noise. By default, Gazebo adds Gaussian noise to the data generated by its sensors to simulate real-world conditions.

## 💻 Lab Procedure

### 🛠 Update `.bashrc`  

Many cadets frequently make mistakes when running `colcon build`. It is crucial to run it inside the `~/master_ws` directory and then source `install/setup.bash`. To prevent errors, follow these instructions carefully:

1. Open `.bashrc` using `gedit`:
    ```bash
    $ gedit ~/.bashrc
    ```

2. Add the following function at the end of the file:
    ```bash
    # Function to build with optional arguments
    function ccbuild() {
    cd ~/master_ws && colcon build --symlink-install "$@"
    source ~/master_ws/install/setup.bash
    }

    # Export the function to make it available in the shell
    export -f ccbuild
    ```

3. Save the file, exit the editor, and restart your terminal.

4. Instead of manually navigating to `~/master_ws`, running `colcon build --symlink-install`, and sourcing `install/setup.bash`, you can now simply run:
    ```bash
    ccbuild
    ```
    This ensures `colcon build` runs in the correct directory and sources the necessary setup file.

5. You can also pass additional arguments to `colcon build`. For example:
    ```bash
    $ ccbuild --packages-select lab6_nav
    ```
    This builds only the `lab6_nav` package, saving time by skipping previously built packages.

By following these steps, you'll streamline your workflow and minimize build-related errors.


### 🛠 Testing IMU on the Physical Robot

1. Use SSH to launch `robot.launch.py` on the robot.
1. Run the `gamepad` and `joy` nodes on the master computer.
1. As you move the robot in Gazebo, observe the `/imu` and `/odom` topics:
    ```bash
    $ ros2 topic echo /imu
    ```
    ```bash
    $ ros2 topic echo /odom
    ```
1. Both topics have too many lines of outputs to easily examine them. Run
    ```bash
    $ ros2 topic echo /imu | grep -A 4 'orientation'
    ```
    ```bash
    $ ros2 topic echo /odom | grep -A 3 'position' | grep -A 4 'orientation'
    ```
    The `-A 3` option in the `grep` command stands for "after context." It tells `grep` to display the specified number of lines following the matching line.
    This command will:
    - Echo messages from the /odom topic.
    - Pipe the output to grep to search for the string 'position'.
    - Display the matching line and the next 3 lines following each match.

    This can be useful when you want to see additional context around the matched lines. In this case, you will see the 'position' section and the next three lines that follow it in the /odom topic messages.


1. Open a terminal and start the TurtleBot3 simulation in Gazebo:
   ```bash
   $ ros2 launch turtlebot3_gazebo turtlebot_world.launch
   ```

### Step 2: Verify Communication with the Master

1. Ensure the TurtleBot3 is properly communicating with the Master by listing active topics:
   ```bash
   $ ros2 topic list
   ```
2. You should see the following topics, including `/imu` and `/odom`:
   ```bash
   /battery_state
   /cmd_vel
   /imu
   /joint_states
   /magnetic_field
   /odom   
   /tf_static
    ```

### Step 3: Examine the `/imu` and `/odom` Topics

1. Run the `gamepad` and `joy` nodes.
2. As you move the robot in Gazebo, observe the `/imu` and `/odom` topics:
   ```bash
   $ ros2 topic echo /imu
   ```
   ```bash
   $ ros2 topic echo /odom
   ```
3. Pay close attention to the `pose` field. In future labs, be careful not to confuse the different pose hierarchies within the `Imu` and `Odom` messages.

### Step 4: Visualizing Data in `rqt`

1. Open `rqt`:
   ```bash
   $ rqt
   ```
2. Move the robot in Gazebo and observe the `/imu` and `/odom` topics in `rqt`.
3. In Gazebo, navigate to `Models` > `burger`, then in the `property` section, select `pose` to display the robot's position and orientation (expressed in roll-pitch-yaw format).
4. In `rqt`, activate the `Topic Monitor` and enable `/imu` and `/odom` to track orientation and position in real time.
5. Note that orientation in `rqt` is shown using quaternions.
6. The pose values in Gazebo and rqt are not the same. Gazebo simulation publishes position and orientation with noise. By default, Gazebo adds Gaussian noise to the data generated by its sensors to simulate real-world conditions.

## 💻 Lab Procedure

### 🛠 Update `.bashrc`  

Many cadets frequently make mistakes when running `colcon build`. It is crucial to run it inside the `~/master_ws` directory and then source `install/setup.bash`. To prevent errors, follow these instructions carefully:

1. Open `.bashrc` using `gedit`:
    ```bash
    $ gedit ~/.bashrc
    ```






1. **Establish a Secure Shell (SSH) Connection** to your TurtleBot3 and launch the core launch file:
   ```bash
   roslaunch turtlebot3_bringup turtlebot3_core.launch
   ```
2. **Check Active Topics** from your Master terminal:
   ```bash
   ros2 topic list
   ```
   Look for `/imu` and `/odom` in the list.
3. **Observe the IMU Data**:
   - Use `ros2 topic echo` to display live data from the `/imu` and `/odom` topics.
   - Rotate the robot and watch the values change.

The `/imu` topic fuses data from the gyroscope and accelerometer to provide orientation, angular velocity, and linear acceleration. The `/odom` topic further incorporates tachometer data to estimate position, orientation, and velocity.

Since both topics report orientation using quaternions, we will convert them to Euler angles for better readability. For this, we will use the Python library [squaternion](https://pypi.org/project/squaternion/).

---

By completing this pre-lab, you will gain hands-on experience interpreting IMU data and understanding how it integrates with the robot’s navigation system. In the next lab, we will use these values to execute precise robot movements.















Create a secure shell connection to your **Robot** and launch the Turtlebot3 core launchfile.

```bash
roslaunch turtlebot3_bringup turtlebot3_core.launch
```

Open a new terminal on your **Master** and observe what topics are running.

You should note two topics of interest: **/imu** and **/odom**.

Echo the output of each of the topics and rotate the **Robot** to see the values change.

The **/imu** topic combines information from the gyroscope and accelerometer to provide orientation, angular velocity, and linear acceleration. The **/odom** topic combines the information from the **/imu** topic and tachometers to estimate position, orientation, and linear and angular velocities.

Both of these topics provide the orientation of the robot using a quaternion representation. While quaternions can make computation easier, they are not very human readable, so we will convert to Euler angles. To do this we will use a Python library called [squaternion](https://pypi.org/project/squaternion/).




1. **Using SSH, launch the `robot.launch.py` file on the robot**:

    ```bash
    $ ros2 launch turt1ebot3_bringup robot.launch
    ```

    Ensure you see **"Run!"** at the end of the output:
    ```bash
    [turtlebot3_ros-3] [INFO] [1738299487.851512798] [turtlebot3_node]: Succeeded to create sound server
    [turtlebot3_ros-3] [INFO] [1738299487.853739761] [turtlebot3_node]: Run!
    [turtlebot3_ros-3] [INFO] [1738299487.890749557] [diff_drive_controller]: Init Odometry
    [turtlebot3_ros-3] [INFO] [1738299487.909780816] [diff_drive_controller]: Run!
    ```


The two main functions we will use from the squaternion library:

First we will need to create a Quaternion object:
```
q = Quaternion(w, x, y, z)
```

Then we will conver that Quaternion to an Euler:
```
e = q.to_euler(degrees=True)
```

Now we have `e`, an array representing our Euler angles, `e[roll, pitch, yaw]`.

You can keep the node running for the next portion of the lesson.



1. Copy and complete the below code using a GUI editor tool, such as **Sublime** or **VS Code**. Browse to the subscriber you just created and double-click. This will open the file in **Sublime** or **VS Code** (if it is open in any other editor, stop, raise your hand, and get help from an instructor)
> 💡️ **Tip:** Look for the **"TODO"** tag which indicates where you should insert your own code.

4. Save, exit, and make the node executable.

4. Open a new terminal on the **Master** and run the **imu_sub.py** node.

4. Rotate the **Robot** and observe the output.

## Checkpoint
Once complete, get checked off by an instructor showing the output of your **imu_sub** and **rqt_graph** node.  Push your ice6 package to your repo for credit

## Summary
In this lesson you learned how to utilize the on-board IMU and determine the orientation of the Turtlebot3. In the lab that corresponds to this lesson you will apply this knowledge to turn the robot in 90 and 180 degree turns.ROS

## Cleanup
In each terminal window, close the node by typing `ctrl+c`. Exit any SSH connections. Shutdown the notebook server by typing `ctrl+c` within the terminal you ran `jupyter-lab` in. Select 'y'.

**Ensure roscore is terminated before moving on to the lab.**

## Purpose
This lab will integrate the on-board IMU with the Turtlebot3 controller to turn the robot 90 degrees left or right.  Do not disable any of the mouse controller functionality in the turtlebot_controller.py code.  The IMU and mouse control functionality should be able to coexist seemlessly.

## Master
### Setup:
In the `/master_ws/src/ece387_master_sp2X-USERNAME/master` folder, create a **lab2** package which depends on **std_msgs**, **rospy**, **geometry_msgs**, and **turtlebot3_bringup**.

### controller.py
1. Copy the turtlebot_controller.py file from lab1 into the lab2 package.

1. Open the turtlebot_controller.py file from lab2 using an editor.

1. Import the squaternion library and Imu message used in ICE6.


## Run your nodes
1. On the **Master** open a terminal and run **roscore**.
1. Open another terminal and enable statistics for **rqt_graph**.
1. Run the controller node.
1. Open secure shell into the **Robot** and run the **turtlebot3_core** launch file.
1. Type "l" or "r" to turn the robot 90 degrees.

## Report
Complete a short 2-3 page report that utilizes the format and answers the questions within the report template. The report template and an example report can be found within the Team under `Resources/Lab Template`.

## Turn-in Requirements
**[25 points]** Demonstration of keyboard control of Turtlebot3 (preferably in person, but can be recorded and posted to Teams under the Lab 2 channel).

**[50 points]** Report via Gradescope.

**[25 points]** Code: push your code to your repository. Also, include a screen shot of the **turtlebot_controller.py** file at the end of your report.











Here’s a **step-by-step guide** to create a **Python ROS2 package** that moves the TurtleBot3 to a desired **location and orientation** using **IMU (`/imu`) and ODOM (`/odom`)** topics in **ROS2 Humble**.  

---

## **🛠 Step 1: Create a New ROS2 Package**  
Open a terminal and create a new package:  
```bash
cd ~/ros2_ws/src  
ros2 pkg create turtlebot3_navigation --build-type ament_python --dependencies rclpy geometry_msgs nav_msgs sensor_msgs
```
This creates a package named `turtlebot3_navigation` with dependencies:  
✅ `rclpy` → ROS2 Python API  
✅ `geometry_msgs` → For `Twist` messages (velocity commands)  
✅ `nav_msgs` → For `Odometry` messages  
✅ `sensor_msgs` → For `IMU` messages  

---

## **📝 Step 2: Write the Python Node**
Create a Python script inside the package:  
```bash
cd ~/ros2_ws/src/turtlebot3_navigation/turtlebot3_navigation
touch move_to_goal.py
chmod +x move_to_goal.py
```

Now, open `move_to_goal.py` and add the following code:  

---

## **📦 Step 3: Update `setup.py`**
Open `setup.py` and modify `entry_points` to include the new script:
```python
entry_points={
    'console_scripts': [
        'move_to_goal = turtlebot3_navigation.move_to_goal:main',
    ],
},
```

---

## **🔧 Step 4: Build and Source the Package**
```bash
cd ~/ros2_ws
colcon build --packages-select turtlebot3_navigation
source install/setup.bash
```

---

## **🚀 Step 5: Run the Node**
```bash
ros2 run turtlebot3_navigation move_to_goal
```

The robot will move to `(1.0, 1.0)` and rotate to face `90°`.

Would you like improvements such as dynamic goal input or PID control for smoother movement? 🚀