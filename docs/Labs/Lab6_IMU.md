# ðŸ”¬ Lab6: IMU


## ðŸ“Œ Objectives

- Students should be able to describe how IMU data is used in ROS2 and interpret IMU messages.
- Students will complete a ROS2 Python node to navigate a robot towards a specified goal position using odometry and IMU data. The robot will follow these steps:

## ðŸ“œ Overview  

In real-world applications, an Inertial Measurement Unit (IMU) provides essential motion data, including orientation, angular velocity, and linear acceleration. The [ICM-20648 6-Axis MEMS MotionTracking Device](https://invensense.tdk.com/products/motion-tracking/6-axis/icm-20648/) from TDK integrates a 3-axis gyroscope, a 3-axis accelerometer, and a Digital Motion Processor (DMP). This IMU is embedded in the OpenCR1.0 board, an open-source robot controller featuring an ARM Cortex-M7 processor. The OpenCR board uses an Extended Kalman Filter (EKF) to fuse sensor data, generating IMU estimates at a rate of 170 updates per second.

```{image} ./figures/IMU.jpg
:width: 380
:align: center
```
<br>

The IMU plays a crucial role in determining the robot's state and enhancing navigation accuracy. When combined with tachometer data, it helps estimate the robot's position over time (odometry). 

```{image} ./figures/TurtleBot3_Coordinates.png
:width: 280
:align: center
```

### IMU Calibration

As mentioned earlier, multiple sensors work together to estimate the TurtleBot3's attitude and heading. These sensors are highly sensitive to magnetic fields, which vary by location and device. Even common electronic components generate small magnetic fields, including those from the OpenCR board itself. While the IMU is strategically placed at the center of the robot for optimal performance, it is still exposed to various magnetic interferences.

Fortunately, the TurtleBot3 developers accounted for this challenge. Each time you run the serial node to connect to the robot, the IMU automatically calibrates itself, ensuring more reliable readings.

## ðŸŒ± Pre-Lab: Testing the IMU  

### Step 1: Launch the TurtleBot3 Simulation

1. Open a terminal and start the TurtleBot3 simulation in Gazebo:
   ```bash
   $ ros2 launch turtlebot3_gazebo turtlebot_world.launch
   ```

### Step 2: Verify Communication with the Master

1. Ensure the TurtleBot3 is properly communicating with the Master by listing active topics:
   ```bash
   $ ros2 topic list
   ```
1. You should see the following topics, including `/imu` and `/odom`:
   ```bash
   /battery_state
   /cmd_vel
   /imu
   /joint_states
   /magnetic_field
   /odom   
   /tf_static
    ```

### Step 3: Examine the `/imu` and `/odom` Topics

1. Run the `gamepad` and `joy` nodes.
1. As you move the robot in Gazebo, observe the `/imu` and `/odom` topics:
   ```bash
   $ ros2 topic echo /imu
   ```
   ```bash
   $ ros2 topic echo /odom
   ```
1. Pay close attention to the `pose` field. In future labs, be careful not to confuse the different pose hierarchies within the `Imu` and `Odom` messages.

### Step 4: Visualizing Data in `rqt`

1. Open `rqt`:
   ```bash
   $ rqt
   ```
1. Move the robot in Gazebo and observe the `/imu` and `/odom` topics in `rqt`.
1. In Gazebo, navigate to `Models` > `burger`, then in the `property` section, select `pose` to display the robot's position and orientation (expressed in roll-pitch-yaw format).
1. In `rqt`, activate the `Topic Monitor` and enable `/imu` and `/odom` to track orientation and position in real time.
1. Note that orientation in `rqt` is shown using quaternions.
1. The pose values in Gazebo and rqt are not the same. Gazebo simulation publishes position and orientation with noise. By default, Gazebo adds Gaussian noise to the data generated by its sensors to simulate real-world conditions.

## ðŸ’» Lab Procedure

### ðŸ›  Update `.bashrc`  

Many cadets frequently make mistakes when running `colcon build`. It is crucial to run it inside the `~/master_ws` directory and then source `install/setup.bash`. To prevent errors, follow these instructions carefully:

1. Open `.bashrc` using `gedit`:
    ```bash
    $ gedit ~/.bashrc
    ```

1. Add the following function at the end of the file:
    ```bash
    # Function to build with optional arguments
    function ccbuild() {
    cd ~/master_ws && colcon build --symlink-install "$@"
    source ~/master_ws/install/setup.bash
    }

    # Export the function to make it available in the shell
    export -f ccbuild
    ```

1. Save the file, exit the editor, and restart your terminal.

1. Instead of manually navigating to `~/master_ws`, running `colcon build --symlink-install`, and sourcing `install/setup.bash`, you can now simply run:
    ```bash
    ccbuild
    ```
    This ensures `colcon build` runs in the correct directory and sources the necessary setup file.

1. You can also pass additional arguments to `colcon build`. For example:
    ```bash
    $ ccbuild --packages-select lab6_nav
    ```
    This builds only the `lab6_nav` package, saving time by skipping previously built packages.

By following these steps, you'll streamline your workflow and minimize build-related errors.


### ðŸ›  Testing IMU on the Physical Robot

1. Use SSH to launch `robot.launch.py` on the robot.
1. Run the `gamepad` and `joy` nodes on the master computer.
1. As you move the robot in Gazebo, observe the `/imu` and `/odom` topics:
    ```bash
    $ ros2 topic echo /imu
    ```
    ```bash
    $ ros2 topic echo /odom
    ```
1. Both topics have too many lines of outputs to easily examine them. Run
    ```bash
    $ ros2 topic echo /imu | grep -A 4 'orientation'
    ```
    ```bash
    $ ros2 topic echo /odom | grep -A 3 'position' 
    ```
    The `-A 3` option in the `grep` command stands for "after context." It tells `grep` to display the specified number of lines following the matching line.
    This command will:
    - Echo messages from the /odom topic.
    - Pipe the output to grep to search for the string 'position'.
    - Display the matching line and the next 3 lines following each match.

    This can be useful when you want to see additional context around the matched lines. In this case, you will see the 'position' section and the next three lines that follow it in the /odom topic messages.

    Both of these topics provide the orientation of the robot using a quaternion representation. While quaternions can make computation easier, they are not very human readable, so we will convert to Euler angles. To do this we will convert quaternions into Euler angles. 

### ðŸ›  **Modify `gamepad.py` to Include Control Relinquishment**

You will modify an existing ROS2 gamepad control node to add functionality for relinquishing and regaining control of the robot. You will implement logic that allows a user to press specific gamepad buttons to toggle control states.

1. Open the `gamepad.py` file located inside `gamepad_control/gamepad.py`:
1. Locate the contructor of the `Gamepad` class and **add the following attributes**:
   ```python
    # Flag to track control status (default: True)
    self.has_control = True

    # Create a publisher for control relinquishment messages.
    # - Publishes to the 'ctrl_relinq' topic.
    # - Uses Bool messages to indicate control status.
    # - Queue size of 1 ensures only the latest control state is kept.
    self.ctrl_pub = self.create_publisher(Bool, 'ctrl_relinq', 1)
    ```

1. In the `joy_callback` method, **add logic for control toggling using buttons 0 and 1**:

    ```python
    # Create a new Bool message for "control relinquishment status"
    relinquish = Bool()

    # TODO: Check if the RC (Remote Control) has control and button O is pressed
        # Set control flag to False (relinquish control)
        # Change "control  status" to relinquished.
        # Publish the control status
        
        # Log status update
        self.get_logger().info("RC has relinquished control.")  

    # TODO: Check if RC does not have control and button X is pressed
        # Set control flag to True (regain control)
        # Set control status to regained.
        # Publish the control status
        
        # Log status update
        self.get_logger().info("RC has taken over control.")  

    # If control is relinquished, stop further processing
    if not self.has_control:
        return
    ```

1. Run the gamepad node. 
1. Open another terminal and monitor the `cmd_vel` topic:
1. Press **button O** on the gamepad and verify that control is relinquished (no movement commands should be published).
1. Press **button X** and verify that control is regained (movement commands should be published again).
1. Check the `ctrl_relinq` topic to see if control status messages are published:


### **Create a Python ROS2 Package**

We want to create a new Python ROS2 package that moves the TurtleBot3 to a desired **location and orientation** using **IMU (`/imu`) and ODOM (`/odom`)** topics.

1. **Create a New ROS2 Package**: Open a terminal and create a new package:  
    ```bash
    $ cd ~/master_ws/src/ece387_ws  
    $ ros2 pkg create lab6_nav --build-type ament_python --dependencies rclpy geometry_msgs nav_msgs sensor_msgs
    ```
    This creates a package named `lab6_nav` with dependencies:  
    - `rclpy` for ROS2 Python API  
    - `geometry_msgs` for `Twist` messages (velocity commands)  
    - `nav_msgs` for `Odometry` messages  
    - `sensor_msgs` for `IMU` messages  

1. **Download `move2goal.py`**: Download [move2goal.py](../files/move2goal.py) and save it under the `~/master_ws/src/ece387_ws/lab6_nav/lab6_nav` directory.

1. **Update `setup.py`**: Open `setup.py` and modify `entry_points` to include the new script:
    ```python
    entry_points={
        'console_scripts': [
            'move2goal = lab6_nav.move2goal:main',
        ],
    },
    ```

1. **Build and Source the Package**
    ```bash
    $ ccbuild 
    ```

### **Write Code for `move2goal.py`**

1. **Initialize Publishers and Subscribers**
   - Implement the missing publisher for `/cmd_vel` to send velocity commands.
   - Implement subscribers for:
     - Odometry (`/odom`) to track position.
     - IMU (`/imu`) to get orientation data.
     - Control status (`/ctrl_relinq`) to check if this node has control.

1. **Implement `odom_callback` Function**
   - Extract `x` and `y` position from the received `Odometry` message.

1. **Implement `imu_callback` Function**
   - Extract quaternion orientation from the `Imu` message.
   - Convert quaternion to Euler angles using `euler_from_quaternion`.
   - Update `yaw` value.

1. **Implement `ctrl_relinq_callback` Function**
   - Update `self.has_control` based on the received `Bool` message.
   - Log a message indicating whether control is taken or relinquished.

1. **Implement `control_loop` Function**
   - Compute the **angle to the goal** and normalize it to `[-$\pi$, $\pi$]`.
   - Compute the **distance to the goal** using Euclidean distance formula.

1. **Complete the State Machine Logic:**
   - **ROTATE_TO_GOAL:**
     - If the angle error is greater than 0.05 radians, rotate with angular speed proportional to the error (`0.3 * angle_error`). Feel free to change this proportional coefficient as you feel better suited. 
     - Otherwise, transition to `MOVE_FORWARD`.
   
   - **MOVE_FORWARD:**
     - Move forward at a constant speed of `0.15` if the goal is not reached. Feed free to change this speed as you like, but the maximum speed of the robot is 0.22.
     - If the distance is less than `0.15`, transition to `ROTATE_TO_FINAL`.

   - **ROTATE_TO_FINAL:**
     - Compute the final orientation error and normalize it.
     - If error is greater than 0.05 radians, rotate with speed proportional to error (`0.5 * final_angle_error`).
     - Otherwise, transition to `GOAL_REACHED`.
   
   - **GOAL_REACHED:**
     - Log a message confirming the goal is reached.
     - Stop publishing movement commands.

1. **Publish the velocity commands in `control_loop`**
   - Ensure `cmd_vel` messages are published correctly in each state.


1. **Build the package** 
    ```bash
    $ ccbuild --packages-select Lab6_nav
    ```

1. Demo your robot moving to (-0.61, 0.61) in meters and rotate to face 90$^\circ$. Hint: Most tiles on the floor and ceiling in the U.S. are measured in feet (of course) and they are usually 1' by 1' and 2' by 2'. How many centimeters is one foot?   



###ðŸšš Deliverables
- Completed `move_to_goal.py` script.
- Demonstration of the working implementation in a real-world setup.
- Carefully examine the distance errors and angle errors printed by move2goal.py and discuss the performance of your robot. If you want to move your robot to a farther distance, e.g., (-3, 3), would it still work? Why and why not?  How would you improve it?








